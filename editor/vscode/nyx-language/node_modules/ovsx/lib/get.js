"use strict";
/********************************************************************************
 * Copyright (c) 2019 TypeFox and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtension = getExtension;
const fs = require("fs");
const path = require("path");
const semver = require("semver");
const registry_1 = require("./registry");
const util_1 = require("./util");
/**
 * Downloads an extension or its metadata.
 */
async function getExtension(options) {
    (0, util_1.addEnvOptions)(options);
    const registry = new registry_1.Registry(options);
    const match = (0, util_1.matchExtensionId)(options.extensionId);
    if (!match) {
        throw new Error('The extension identifier must have the form `namespace.extension`.');
    }
    const extension = await registry.getMetadata(match[1], match[2], options.target);
    if (extension.error) {
        throw new Error(extension.error);
    }
    const matchingVersion = await findMatchingVersion(registry, extension, options.version);
    if (matchingVersion.error) {
        throw new Error(matchingVersion.error);
    }
    if (options.metadata) {
        await printMetadata(registry, matchingVersion, options.output);
    }
    else {
        await download(registry, matchingVersion, options.output);
    }
}
function findMatchingVersion(registry, extension, constraint) {
    if (!constraint || semver.satisfies(extension.version, constraint)) {
        return Promise.resolve(extension);
    }
    for (const version of Object.keys(extension.allVersions)) {
        if (!isAlias(extension, version) && semver.satisfies(version, constraint)) {
            try {
                return registry.getJson(new URL(extension.allVersions[version]));
            }
            catch (err) {
                return (0, util_1.rejectError)(err);
            }
        }
    }
    return Promise.reject(new Error(`Extension ${extension.namespace}.${extension.name} has no published version matching '${constraint}'`));
}
function isAlias(extension, version) {
    return extension.versionAlias.includes(version);
}
async function printMetadata(registry, extension, output) {
    const metadata = JSON.stringify(extension, null, 4);
    if (!output) {
        console.log(metadata);
        return;
    }
    let filePath;
    const stats = await (0, util_1.optionalStat)(output);
    if (stats?.isDirectory() || !stats && output.endsWith(path.sep)) {
        const fileName = `${extension.namespace}.${extension.name}-${extension.version}.json`;
        filePath = path.resolve(process.cwd(), output, fileName);
    }
    else {
        filePath = path.resolve(process.cwd(), output);
    }
    await (0, util_1.makeDirs)(path.dirname(filePath));
    await (0, util_1.promisify)(fs.writeFile)(filePath, metadata);
}
async function download(registry, extension, output) {
    const downloadUrl = extension.files.download;
    if (!downloadUrl) {
        throw new Error(`Extension ${extension.namespace}.${extension.name} does not provide a download URL.`);
    }
    const fileNameIndex = downloadUrl.lastIndexOf('/');
    const fileName = decodeURIComponent(downloadUrl.substring(fileNameIndex + 1));
    let filePath;
    if (output) {
        const stats = await (0, util_1.optionalStat)(output);
        if (stats?.isDirectory() || !stats && output.endsWith(path.sep)) {
            filePath = path.resolve(process.cwd(), output, fileName);
        }
        else {
            filePath = path.resolve(process.cwd(), output);
        }
    }
    else {
        filePath = path.resolve(process.cwd(), fileName);
    }
    await (0, util_1.makeDirs)(path.dirname(filePath));
    const target = extension.targetPlatform !== 'universal' ? '@' + extension.targetPlatform : '';
    console.log(`Downloading ${extension.namespace}.${extension.name}-${extension.version}${target} to ${filePath}`);
    await registry.download(filePath, new URL(downloadUrl));
}
//# sourceMappingURL=get.js.map