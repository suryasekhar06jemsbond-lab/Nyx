"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publish = publish;
/********************************************************************************
 * Copyright (c) 2019 TypeFox and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
const vsce_1 = require("@vscode/vsce");
const pat_1 = require("./pat");
const util_1 = require("./util");
const registry_1 = require("./registry");
const check_license_1 = require("./check-license");
const zip_1 = require("./zip");
/**
 * Publishes an extension.
 */
async function publish(options = {}) {
    (0, util_1.addEnvOptions)(options);
    const internalPublishOptions = [];
    const packagePaths = options.packagePath || [undefined];
    const targets = options.targets || [undefined];
    for (const packagePath of packagePaths) {
        for (const target of targets) {
            internalPublishOptions.push({ ...options, packagePath: packagePath, target: target });
        }
    }
    return Promise.allSettled(internalPublishOptions.map(publishOptions => doPublish(publishOptions)));
}
async function doPublish(options = {}) {
    // if the packagePath is a link to a vsix, don't need to package it
    if (options.packagePath?.endsWith('.vsix')) {
        options.extensionFile = options.packagePath;
        delete options.packagePath;
        delete options.target;
    }
    const registry = new registry_1.Registry(options);
    if (!options.extensionFile) {
        await packageExtension(options, registry);
        console.log(); // new line
    }
    else if (options.preRelease) {
        console.warn("Ignoring option '--pre-release' for prepackaged extension.");
    }
    if (!options.pat) {
        const namespace = (await (0, zip_1.readVSIXPackage)(options.extensionFile)).publisher;
        options.pat = await (0, pat_1.getPAT)(namespace, options);
    }
    let extension;
    try {
        extension = await registry.publish(options.extensionFile, options.pat);
    }
    catch (err) {
        if (options.skipDuplicate && err.message.endsWith('is already published.')) {
            console.log(err.message + ' Skipping publish.');
            return;
        }
        else {
            throw err;
        }
    }
    if (extension.error) {
        throw new Error(extension.error);
    }
    const name = `${extension.namespace}.${extension.name}`;
    let description = `${name} v${extension.version}`;
    if (extension.targetPlatform !== 'universal') {
        description += `@${extension.targetPlatform}`;
    }
    console.log(`\ud83d\ude80  Published ${description}`);
    if (extension.warning) {
        console.log(`\n!!  ${extension.warning}`);
    }
}
async function packageExtension(options, registry) {
    if (registry.requiresLicense) {
        await (0, check_license_1.checkLicense)(options.packagePath);
    }
    options.extensionFile = await (0, util_1.createTempFile)({ postfix: '.vsix' });
    const packageOptions = {
        packagePath: options.extensionFile,
        target: options.target,
        cwd: options.packagePath,
        baseContentUrl: options.baseContentUrl,
        baseImagesUrl: options.baseImagesUrl,
        useYarn: options.yarn,
        dependencies: options.dependencies,
        preRelease: options.preRelease,
        version: options.packageVersion
    };
    await (0, vsce_1.createVSIX)(packageOptions);
}
//# sourceMappingURL=publish.js.map