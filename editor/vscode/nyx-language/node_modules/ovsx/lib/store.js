"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeytarStore = exports.FileStore = void 0;
exports.openDefaultStore = openDefaultStore;
/********************************************************************************
 * Copyright (c) 2024 Precies. Software and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
const fs = require("fs");
const path = require("path");
const os_1 = require("os");
class FileStore {
    static async open(path = FileStore.DefaultPath) {
        try {
            const rawStore = await fs.promises.readFile(path, 'utf8');
            return new FileStore(path, JSON.parse(rawStore).entries);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return new FileStore(path, []);
            }
            else if (/SyntaxError/.test(err)) {
                throw new Error(`Error parsing file store: ${path}.`);
            }
            throw err;
        }
    }
    get size() {
        return this.entries.length;
    }
    constructor(path, entries) {
        this.path = path;
        this.entries = entries;
    }
    async save() {
        await fs.promises.writeFile(this.path, JSON.stringify({ entries: this.entries }), { mode: '0600' });
    }
    async deleteStore() {
        try {
            await fs.promises.unlink(this.path);
        }
        catch {
            // noop
        }
    }
    get(name) {
        return this.entries.find(p => p.name === name)?.value;
    }
    async add(name, value) {
        const newEntry = { name, value };
        this.entries = [...this.entries.filter(p => p.name !== name), newEntry];
        await this.save();
    }
    async delete(name) {
        this.entries = this.entries.filter(p => p.name !== name);
        await this.save();
    }
    [Symbol.iterator]() {
        return this.entries[Symbol.iterator]();
    }
}
exports.FileStore = FileStore;
FileStore.DefaultPath = path.join((0, os_1.homedir)(), '.ovsx');
class KeytarStore {
    static async open(serviceName = 'ovsx') {
        const keytar = await Promise.resolve().then(() => require('keytar'));
        const creds = await keytar.findCredentials(serviceName);
        return new KeytarStore(keytar, serviceName, creds.map(({ account, password }) => ({ name: account, value: password })));
    }
    get size() {
        return this.entries.length;
    }
    constructor(keytar, serviceName, entries) {
        this.keytar = keytar;
        this.serviceName = serviceName;
        this.entries = entries;
    }
    get(name) {
        return this.entries.find(p => p.name === name)?.value;
    }
    async add(name, value) {
        const newEntry = { name, value };
        this.entries = [...this.entries.filter(p => p.name !== name), newEntry];
        await this.keytar.setPassword(this.serviceName, name, value);
    }
    async delete(name) {
        this.entries = this.entries.filter(p => p.name !== name);
        await this.keytar.deletePassword(this.serviceName, name);
    }
    [Symbol.iterator]() {
        return this.entries[Symbol.iterator]();
    }
}
exports.KeytarStore = KeytarStore;
async function openDefaultStore() {
    if (/^file$/i.test(process.env['OVSX_STORE'] ?? '')) {
        return await FileStore.open();
    }
    let keytarStore;
    try {
        keytarStore = await KeytarStore.open();
    }
    catch (err) {
        const store = await FileStore.open();
        console.warn(`Failed to open credential store. Falling back to storing secrets clear-text in: ${store.path}.`);
        return store;
    }
    const fileStore = await FileStore.open();
    // migrate from file store
    if (fileStore.size) {
        for (const { name, value } of fileStore) {
            await keytarStore.add(name, value);
        }
        await fileStore.deleteStore();
        console.info(`Migrated ${fileStore.size} publishers to system credential manager. Deleted local store '${fileStore.path}'.`);
    }
    return keytarStore;
}
//# sourceMappingURL=store.js.map