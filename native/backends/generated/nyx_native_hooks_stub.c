/* Auto-generated by scripts/generate_native_backend_stubs.py */
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "nyx_native_hooks.h"

static unsigned long long nyx_fnv1a(const unsigned char *data, long long len) {
    unsigned long long h = 1469598103934665603ULL;
    if (!data || len <= 0) {
        return h;
    }
    for (long long i = 0; i < len; i++) {
        h ^= (unsigned long long)data[i];
        h *= 1099511628211ULL;
    }
    return h;
}

static unsigned long long nyx_hash_cstr(const char *s) {
    if (!s) {
        return nyx_fnv1a(NULL, 0);
    }
    const unsigned char *p = (const unsigned char *)s;
    long long n = 0;
    while (p[n] != 0) n++;
    return nyx_fnv1a(p, n);
}

static void nyx_copy_str(char *dst, size_t cap, const char *src, const char *fallback) {
    if (!dst || cap == 0) return;
    const char *in = src && *src ? src : fallback;
    if (!in) in = "";
    size_t i = 0;
    while (i + 1 < cap && in[i] != 0) {
        dst[i] = in[i];
        i++;
    }
    dst[i] = 0;
}

static double nyx_clamp(double v, double lo, double hi) {
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

static NyxBytes nyx_empty_bytes(void) {
    NyxBytes b;
    b.data = NULL;
    b.len = 0;
    return b;
}

static NyxStringList nyx_empty_string_list(void) {
    NyxStringList s;
    s.items = NULL;
    s.len = 0;
    return s;
}

static NyxTuple2I32 nyx_zero_tuple2_i32(void) {
    NyxTuple2I32 t;
    t.a = 0;
    t.b = 0;
    return t;
}

#define NYX_BLOB_SLOTS 32
#define NYX_BLOB_CAP 1024
static unsigned char g_blob_slots[NYX_BLOB_SLOTS][NYX_BLOB_CAP];
static long long g_blob_lens[NYX_BLOB_SLOTS];
static int g_blob_cursor = 0;

static NyxBytes nyx_blob_from_text(const char *text) {
    NyxBytes out;
    if (!text) return nyx_empty_bytes();
    int slot = g_blob_cursor++ % NYX_BLOB_SLOTS;
    long long i = 0;
    while (i + 1 < NYX_BLOB_CAP && text[i] != 0) {
        g_blob_slots[slot][i] = (unsigned char)text[i];
        i++;
    }
    g_blob_slots[slot][i] = 0;
    g_blob_lens[slot] = i;
    out.data = g_blob_slots[slot];
    out.len = i;
    return out;
}

static NyxBytes nyx_blob_from_bytes(const unsigned char *data, long long len) {
    NyxBytes out;
    if (!data || len <= 0) return nyx_empty_bytes();
    int slot = g_blob_cursor++ % NYX_BLOB_SLOTS;
    long long n = len < (NYX_BLOB_CAP - 1) ? len : (NYX_BLOB_CAP - 1);
    for (long long i = 0; i < n; i++) {
        g_blob_slots[slot][i] = data[i];
    }
    g_blob_slots[slot][n] = 0;
    g_blob_lens[slot] = n;
    out.data = g_blob_slots[slot];
    out.len = n;
    return out;
}

static const char *nyx_hex_u64(unsigned long long v) {
    static char ring[32][32];
    static int cursor = 0;
    int slot = cursor++ % 32;
    (void)snprintf(ring[slot], sizeof(ring[slot]), "%016llx", v);
    return ring[slot];
}

static double nyx_parse_first_double(NyxBytes blob, double fallback) {
    if (!blob.data || blob.len <= 0) return fallback;
    char local[128];
    long long n = blob.len < 127 ? blob.len : 127;
    for (long long i = 0; i < n; i++) local[i] = (char)blob.data[i];
    local[n] = 0;
    char *endp = NULL;
    double v = strtod(local, &endp);
    if (endp == local) return fallback;
    return v;
}

#define NYX_LIST_SLOTS 16
#define NYX_LIST_ITEMS 8
#define NYX_LIST_STR 64
static const char *g_list_items[NYX_LIST_SLOTS][NYX_LIST_ITEMS];
static char g_list_storage[NYX_LIST_SLOTS][NYX_LIST_ITEMS][NYX_LIST_STR];
static int g_list_cursor = 0;

static NyxStringList nyx_string_list_from4(const char *a, const char *b, const char *c, const char *d) {
    NyxStringList out;
    int slot = g_list_cursor++ % NYX_LIST_SLOTS;
    const char *vals[4] = {a, b, c, d};
    long long count = 0;
    for (int i = 0; i < 4; i++) {
        if (!vals[i] || vals[i][0] == 0) continue;
        nyx_copy_str(g_list_storage[slot][count], NYX_LIST_STR, vals[i], "");
        g_list_items[slot][count] = g_list_storage[slot][count];
        count++;
    }
    out.items = g_list_items[slot];
    out.len = count;
    return out;
}

typedef struct NyxRenderState {
    int booted;
    char backend[32];
    long long width;
    long long height;
    char tier[16];
    long long registered_materials;
    long long gpu_memory_mb;
    double last_gpu_ms;
} NyxRenderState;

static NyxRenderState g_render = {0, "vulkan", 1920, 1080, "high", 0, 4096, 8.0};

typedef struct NyxPhysicsState {
    int booted;
    char float_mode[32];
    char template_id[32];
    double step_ms;
    unsigned long long last_checksum;
} NyxPhysicsState;

static NyxPhysicsState g_physics = {0, "deterministic_fp32", "realistic", 2.5, 0ULL};

typedef struct NyxAIState {
    double frame_ms;
    long long last_sandbox_steps;
    unsigned long long last_intent_hash;
} NyxAIState;

static NyxAIState g_ai = {1.2, 0, 0ULL};

typedef struct NyxNetState {
    double tick_ms;
    double packet_loss_pct;
    unsigned long long last_world_hash;
    long long desync_count;
} NyxNetState;

static NyxNetState g_net = {2.0, 0.2, 0ULL, 0};

typedef struct NyxAudioState {
    char active_backend[16];
    double master_volume;
    double listener[3];
    long long active_sources;
    long long filters;
    long long reverbs;
    long long voice_peers;
    double dsp_ms;
    double lufs;
} NyxAudioState;

static NyxAudioState g_audio = {{'w','a','s','a','p','i',0}, 1.0, {0.0, 0.0, 0.0}, 0, 0, 0, 1, 1.0, -16.0};

typedef struct NyxLogicState {
    long long executed_actions;
    long long mutation_count;
    double profile_ms;
    unsigned long long last_rule_hash;
} NyxLogicState;

static NyxLogicState g_logic = {0, 0, 0.8, 0ULL};

static int g_nygame_last_sync_ok = 0;

typedef struct NyxCapabilityContractEntry {
    const char *engine;
    const char *profile;
    const char *capability;
} NyxCapabilityContractEntry;

static const NyxCapabilityContractEntry g_nygame_capability_contract[] = {
    {"nycore", "core", "allocators"},
    {"nycore", "core", "work_stealing"},
    {"nycore", "core", "numa_aware"},
    {"nycore", "core", "task_graph"},
    {"nycore", "core", "ecs"},
    {"nycore", "core", "platform_abstraction"},
    {"nycore", "core", "lock_free_primitives"},
    {"nycore", "core", "fiber_runtime"},
    {"nycore", "core", "observability"},
    {"nycore", "core", "resilience"},
    {"nycore", "core", "serialization"},
    {"nycore", "core", "deterministic_task_ordering"},
    {"nycore", "core", "memory_fragmentation_metrics"},
    {"nycore", "core", "simd_dispatch"},
    {"nycore", "core", "runtime_schema_compiler"},
    {"nycore", "core", "self_optimizing_runtime"},
    {"nycore", "core", "self_validating_pipeline"},
    {"nycore", "nocode", "visual_task_graph_designer"},
    {"nycore", "nocode", "declarative_ecs_rules"},
    {"nycore", "nocode", "runtime_schema_compiler"},
    {"nycore", "nocode", "self_optimizing_runtime"},
    {"nycore", "nocode", "self_validating_pipeline"},
    {"nycore", "nocode", "runtime_system_hot_mutation"},
    {"nycore", "nocode", "graph_based_orchestration"},
    {"nycore", "nocode", "data_driven_behavior"},
    {"nycore", "nocode", "automatic_performance_optimization"},
    {"nycore", "production", "production_health"},
    {"nycore", "production", "deterministic_task_ordering"},
    {"nycore", "production", "memory_fragmentation_metrics"},
    {"nycore", "production", "simd_dispatch"},
    {"nycore", "production", "observability"},
    {"nycore", "production", "resilience"},
    {"nycore", "production", "platform_abstraction"},
    {"nycore", "production", "numa_aware"},
    {"nyrender", "core", "spectral_pbr"},
    {"nyrender", "core", "energy_conserving_brdf"},
    {"nyrender", "core", "layered_materials"},
    {"nyrender", "core", "subsurface_scattering"},
    {"nyrender", "core", "thin_film"},
    {"nyrender", "core", "realtime_material_graph_compiler"},
    {"nyrender", "core", "neural_material_compression"},
    {"nyrender", "core", "hardware_rt_cores"},
    {"nyrender", "core", "hybrid_rt"},
    {"nyrender", "core", "rt_reflections"},
    {"nyrender", "core", "soft_shadows_rt"},
    {"nyrender", "core", "rt_transparency"},
    {"nyrender", "core", "path_tracing"},
    {"nyrender", "core", "neural_radiance_gi_cache"},
    {"nyrender", "core", "realtime_gi"},
    {"nyrender", "core", "voxel_cone_tracing"},
    {"nyrender", "core", "screen_space_gi"},
    {"nyrender", "core", "probe_gi_streaming"},
    {"nyrender", "core", "time_of_day_relighting"},
    {"nyrender", "core", "world_light_propagation"},
    {"nyrender", "core", "persistent_light_memory"},
    {"nyrender", "core", "virtual_geometry"},
    {"nyrender", "core", "per_triangle_culling"},
    {"nyrender", "core", "cluster_rendering"},
    {"nyrender", "core", "mesh_streaming"},
    {"nyrender", "core", "mesh_shader_integration"},
    {"nyrender", "core", "automatic_lod_generation"},
    {"nyrender", "core", "ai_mesh_decimation"},
    {"nyrender", "core", "geometry_compression"},
    {"nyrender", "core", "hdr_pipeline"},
    {"nyrender", "core", "aces_tonemap"},
    {"nyrender", "core", "auto_exposure"},
    {"nyrender", "core", "camera_simulation"},
    {"nyrender", "core", "vulkan_backend"},
    {"nyrender", "core", "directx12_backend"},
    {"nyrender", "core", "metal_backend_future"},
    {"nyrender", "core", "webgpu_backend_experimental"},
    {"nyrender", "core", "shader_hot_reload"},
    {"nyrender", "core", "shader_permutation_reduction"},
    {"nyrender", "core", "ai_shader_optimization"},
    {"nyrender", "core", "indirect_draw"},
    {"nyrender", "core", "compute_visibility"},
    {"nyrender", "core", "gpu_occlusion_culling"},
    {"nyrender", "core", "async_compute"},
    {"nyrender", "core", "frame_graph"},
    {"nyrender", "core", "denoising"},
    {"nyrender", "nocode", "node_material_graph_only"},
    {"nyrender", "nocode", "ai_material_generation"},
    {"nyrender", "nocode", "visual_pipeline_graph"},
    {"nyrender", "nocode", "auto_performance_tiering"},
    {"nyrender", "nocode", "declarative_render_pipeline"},
    {"nyrender", "nocode", "no_shader_authoring"},
    {"nyrender", "production", "production_health"},
    {"nyrender", "production", "gpu_residency_manager"},
    {"nyrender", "production", "adaptive_quality"},
    {"nyrender", "production", "gpu_diagnostics"},
    {"nyrender", "production", "frame_graph"},
    {"nyrender", "production", "denoising"},
    {"nyphysics", "core", "ccd"},
    {"nyphysics", "core", "deterministic_mode"},
    {"nyphysics", "core", "constraint_solvers"},
    {"nyphysics", "core", "fem_softbody"},
    {"nyphysics", "core", "softbody_realtime_deformation"},
    {"nyphysics", "core", "breakable_topology"},
    {"nyphysics", "core", "vehicle_dynamics"},
    {"nyphysics", "core", "torque_distribution"},
    {"nyphysics", "core", "suspension_geometry"},
    {"nyphysics", "core", "weight_transfer"},
    {"nyphysics", "core", "surface_grip"},
    {"nyphysics", "core", "ml_vehicle_tuning"},
    {"nyphysics", "core", "procedural_fracture"},
    {"nyphysics", "core", "structural_stress"},
    {"nyphysics", "core", "debris_lifecycle"},
    {"nyphysics", "core", "gpu_fracture_solver"},
    {"nyphysics", "core", "gpu_cloth"},
    {"nyphysics", "core", "cloth_wind"},
    {"nyphysics", "core", "cloth_collision"},
    {"nyphysics", "core", "fft_ocean"},
    {"nyphysics", "core", "buoyancy"},
    {"nyphysics", "core", "wake_simulation"},
    {"nyphysics", "core", "shoreline_interaction"},
    {"nyphysics", "core", "broadphase_bvh_spatial_hash"},
    {"nyphysics", "core", "gjk_epa"},
    {"nyphysics", "core", "multithreaded_solver"},
    {"nyphysics", "nocode", "visual_constraint_graph"},
    {"nyphysics", "nocode", "physical_templates"},
    {"nyphysics", "nocode", "ai_solver_tuning"},
    {"nyphysics", "nocode", "rule_based_destruction"},
    {"nyphysics", "nocode", "constraint_graph_runtime"},
    {"nyphysics", "nocode", "no_manual_physics_code"},
    {"nyphysics", "production", "production_health"},
    {"nyphysics", "production", "cross_platform_determinism"},
    {"nyphysics", "production", "rollback"},
    {"nyphysics", "production", "replay"},
    {"nyphysics", "production", "gpu_rigidbody_solver"},
    {"nyphysics", "production", "region_activation"},
    {"nyphysics", "production", "multithreaded_solver"},
    {"nyworld", "core", "partition_grid"},
    {"nyworld", "core", "hierarchical_zones"},
    {"nyworld", "core", "predictive_streaming"},
    {"nyworld", "core", "async_io"},
    {"nyworld", "core", "compression_aware_loading"},
    {"nyworld", "core", "ssd_optimized_layouts"},
    {"nyworld", "core", "procedural_terrain"},
    {"nyworld", "core", "biome_blending"},
    {"nyworld", "core", "runtime_terrain_modification"},
    {"nyworld", "core", "city_generation"},
    {"nyworld", "core", "traffic_aware_roads"},
    {"nyworld", "core", "ai_building_variation"},
    {"nyworld", "core", "navmesh_streaming"},
    {"nyworld", "core", "dynamic_navmesh_rebuild"},
    {"nyworld", "core", "sector_pathing"},
    {"nyworld", "core", "crowd_aware_routing"},
    {"nyworld", "core", "npc_scaling"},
    {"nyworld", "core", "behavioral_abstraction"},
    {"nyworld", "core", "memory_budgeting"},
    {"nyworld", "core", "predictive_eviction"},
    {"nyworld", "core", "gpu_memory_monitoring"},
    {"nyworld", "core", "world_persistence"},
    {"nyworld", "core", "climate_simulation"},
    {"nyworld", "nocode", "procedural_rule_designer"},
    {"nyworld", "nocode", "ai_streaming_prediction"},
    {"nyworld", "nocode", "declarative_economy_layer"},
    {"nyworld", "nocode", "world_behavior_authoring"},
    {"nyworld", "nocode", "no_manual_world_scripts"},
    {"nyworld", "production", "production_health"},
    {"nyworld", "production", "layered_world_simulation"},
    {"nyworld", "production", "streaming_heatmap"},
    {"nyworld", "production", "streaming_observability"},
    {"nyworld", "production", "systemic_events"},
    {"nyworld", "production", "replication_bridge"},
    {"nyworld", "production", "world_persistence"},
    {"nyworld", "production", "climate_simulation"},
    {"nyai", "core", "bt_goap_hybrid"},
    {"nyai", "core", "hierarchical_pathfinding"},
    {"nyai", "core", "dynamic_obstacle_avoidance"},
    {"nyai", "core", "realtime_rerouting"},
    {"nyai", "core", "crowd_simulation"},
    {"nyai", "core", "local_avoidance"},
    {"nyai", "core", "density_control"},
    {"nyai", "core", "panic_models"},
    {"nyai", "core", "police_system"},
    {"nyai", "core", "heat_escalation"},
    {"nyai", "core", "strategic_roadblocks"},
    {"nyai", "core", "helicopter_tracking"},
    {"nyai", "core", "combat_ai"},
    {"nyai", "core", "cover_system"},
    {"nyai", "core", "tactical_flanking"},
    {"nyai", "core", "squad_communication"},
    {"nyai", "core", "social_simulation"},
    {"nyai", "core", "memory_model_per_npc"},
    {"nyai", "core", "relationship_graphs"},
    {"nyai", "core", "economy_interaction"},
    {"nyai", "core", "rumor_propagation"},
    {"nyai", "nocode", "intent_behavior_authoring"},
    {"nyai", "nocode", "data_defined_memory_graph"},
    {"nyai", "nocode", "ai_sandbox_simulation"},
    {"nyai", "nocode", "no_behavior_tree_scripting"},
    {"nyai", "production", "production_health"},
    {"nyai", "production", "ai_budget_governor"},
    {"nyai", "production", "persistent_memory"},
    {"nyai", "production", "utility_ai"},
    {"nyai", "production", "perception_stack"},
    {"nyai", "production", "ai_observability"},
    {"nynet", "core", "authoritative_server"},
    {"nynet", "core", "deterministic_sync"},
    {"nynet", "core", "snapshot_interpolation"},
    {"nynet", "core", "rewind_compensation"},
    {"nynet", "core", "anti_cheat"},
    {"nynet", "core", "kernel_validation"},
    {"nynet", "core", "anomaly_detection"},
    {"nynet", "core", "server_sanity_checks"},
    {"nynet", "core", "regional_scaling"},
    {"nynet", "core", "load_balancing"},
    {"nynet", "core", "microservices_backend"},
    {"nynet", "core", "transport_channels"},
    {"nynet", "core", "matchmaking"},
    {"nynet", "core", "secure_networking"},
    {"nynet", "nocode", "replication_auto_discovery"},
    {"nynet", "nocode", "automatic_interest_management"},
    {"nynet", "nocode", "deterministic_desync_validation"},
    {"nynet", "nocode", "no_manual_network_schema"},
    {"nynet", "production", "production_health"},
    {"nynet", "production", "adaptive_qos"},
    {"nynet", "production", "failover_ops"},
    {"nynet", "production", "determinism_validation"},
    {"nynet", "production", "interest_management"},
    {"nynet", "production", "server_partitioning"},
    {"nyaudio", "core", "hrtf"},
    {"nyaudio", "core", "occlusion"},
    {"nyaudio", "core", "doppler"},
    {"nyaudio", "core", "convolution_reverb"},
    {"nyaudio", "core", "dynamic_music"},
    {"nyaudio", "core", "ai_ambience"},
    {"nyaudio", "core", "mix_buses"},
    {"nyaudio", "core", "dsp_chain"},
    {"nyaudio", "core", "voice_chat"},
    {"nyaudio", "core", "loudness_management"},
    {"nyaudio", "core", "acoustic_propagation"},
    {"nyaudio", "core", "backend_failover"},
    {"nyaudio", "nocode", "visual_acoustic_graph"},
    {"nyaudio", "nocode", "emotional_music_director"},
    {"nyaudio", "nocode", "emotional_music_state_machine"},
    {"nyaudio", "nocode", "no_manual_dsp_graph"},
    {"nyaudio", "production", "production_health"},
    {"nyaudio", "production", "audio_observability"},
    {"nyaudio", "production", "audio_zones"},
    {"nyaudio", "production", "acoustic_propagation"},
    {"nyaudio", "production", "backend_failover"},
    {"nyanim", "core", "full_body_ik"},
    {"nyanim", "core", "motion_matching"},
    {"nyanim", "core", "facial_muscles"},
    {"nyanim", "core", "blend_trees"},
    {"nyanim", "core", "procedural_blend"},
    {"nyanim", "core", "ai_locomotion"},
    {"nyanim", "core", "learned_locomotion"},
    {"nyanim", "core", "retargeting"},
    {"nyanim", "core", "motion_warping"},
    {"nyanim", "core", "clip_streaming"},
    {"nyanim", "core", "anim_events"},
    {"nyanim", "nocode", "intent_motion_synthesis"},
    {"nyanim", "nocode", "physics_aware_adaptation"},
    {"nyanim", "nocode", "no_manual_state_machine"},
    {"nyanim", "production", "production_health"},
    {"nyanim", "production", "animation_network_sync"},
    {"nyanim", "production", "physics_animation_coupling"},
    {"nyanim", "production", "state_graph"},
    {"nyanim", "production", "clip_streaming"},
    {"nylogic", "core", "rule_dsl"},
    {"nylogic", "core", "declarative_runtime"},
    {"nylogic", "core", "graph_orchestration"},
    {"nylogic", "core", "ai_rule_generation"},
    {"nylogic", "core", "hot_mutation"},
    {"nylogic", "core", "self_validating_rules"},
    {"nylogic", "core", "automatic_optimization"},
    {"nylogic", "nocode", "visual_rule_authoring"},
    {"nylogic", "nocode", "intent_rule_generation"},
    {"nylogic", "nocode", "runtime_hot_mutation"},
    {"nylogic", "nocode", "no_imperative_scripting"},
    {"nylogic", "nocode", "self_validating_rules"},
    {"nylogic", "production", "production_health"},
    {"nylogic", "production", "automatic_optimization"},
    {"nylogic", "production", "self_validating_rules"},
    {"nylogic", "production", "logic_observability"},
    {"nylogic", "production", "determinism_rule_replay"},
};
static const size_t g_nygame_capability_contract_len = sizeof(g_nygame_capability_contract) / sizeof(g_nygame_capability_contract[0]);

static int nyx_contract_has_capability(const char *engine, const char *capability) {
    if (!engine || !capability || engine[0] == 0 || capability[0] == 0) return 0;
    for (size_t i = 0; i < g_nygame_capability_contract_len; i++) {
        const NyxCapabilityContractEntry *it = &g_nygame_capability_contract[i];
        if (strcmp(it->engine, engine) != 0) continue;
        if (strcmp(it->capability, capability) == 0) return 1;
    }
    return 0;
}

static int nyx_contract_has_profile(const char *engine, const char *profile) {
    if (!engine || !profile || engine[0] == 0 || profile[0] == 0) return 0;
    int saw = 0;
    for (size_t i = 0; i < g_nygame_capability_contract_len; i++) {
        const NyxCapabilityContractEntry *it = &g_nygame_capability_contract[i];
        if (strcmp(it->engine, engine) != 0) continue;
        if (strcmp(it->profile, profile) != 0) continue;
        saw = 1;
        if (!nyx_contract_has_capability(engine, it->capability)) return 0;
    }
    return saw ? 1 : 0;
}

double native_ai_frame_time_ms(void) {
    return g_ai.frame_ms;
}
int native_anim_state_sync_ok(void) {
    return 0;
}
double native_anim_update_ms(void) {
    return 0.0;
}
int native_asset_has_changed(const char * path) {
    (void)path;
    return 0;
}
void * native_asset_load_audio(const char * path) {
    (void)path;
    return NULL;
}
void * native_asset_load_font(const char * path, long long size) {
    (void)path;
    (void)size;
    return NULL;
}
void * native_asset_load_mesh(const char * path) {
    (void)path;
    return NULL;
}
void * native_asset_load_model(const char * path) {
    (void)path;
    return NULL;
}
void * native_asset_load_shader(const char * path) {
    (void)path;
    return NULL;
}
void * native_asset_load_texture(const char * path) {
    (void)path;
    return NULL;
}
void native_audio_add_filter(long long source_id, void * filter_type, double frequency, double q) {
    (void)source_id;
    (void)filter_type;
    (void)frequency;
    (void)q;
    g_audio.filters++;
    g_audio.dsp_ms = nyx_clamp(g_audio.dsp_ms + 0.05, 0.2, 20.0);
}
void native_audio_add_reverb(long long source_id, double room_size, double damping) {
    (void)source_id;
    (void)room_size;
    (void)damping;
    g_audio.reverbs++;
    g_audio.dsp_ms = nyx_clamp(g_audio.dsp_ms + 0.09, 0.2, 20.0);
}
int native_audio_backend_alive(const char * backend) {
    if (!backend) return 0;
    if (strcmp(backend, "wasapi") == 0) return 1;
    if (strcmp(backend, "alsa") == 0) return 1;
    if (strcmp(backend, "coreaudio") == 0) return 1;
    if (strcmp(backend, g_audio.active_backend) == 0) return 1;
    return 0;
}
void * native_audio_create_context(void) {
    nyx_copy_str(g_audio.active_backend, sizeof(g_audio.active_backend), "wasapi", "wasapi");
    g_audio.master_volume = 1.0;
    g_audio.active_sources = 0;
    g_audio.filters = 0;
    g_audio.reverbs = 0;
    g_audio.voice_peers = 1;
    g_audio.dsp_ms = 1.0;
    g_audio.lufs = -16.0;
    return &g_audio;
}
double native_audio_dsp_time_ms(void) {
    return g_audio.dsp_ms;
}
double native_audio_integrated_lufs(void) {
    return g_audio.lufs - (1.0 - g_audio.master_volume) * 4.0;
}
void * native_audio_load_buffer(const char * path) {
    static unsigned long long ids[128];
    static int cursor = 0;
    int slot = cursor++ % 128;
    ids[slot] = nyx_hash_cstr(path);
    return &ids[slot];
}
void native_audio_play(long long source_id) {
    (void)source_id;
    g_audio.active_sources++;
    g_audio.dsp_ms = nyx_clamp(0.7 + (double)g_audio.active_sources * 0.15 + (double)g_audio.filters * 0.05 + (double)g_audio.reverbs * 0.08, 0.2, 20.0);
    g_audio.lufs = -16.0 + (double)g_audio.active_sources * 0.25;
}
void native_audio_set_listener(void * position, void * forward, void * up) {
    (void)forward;
    (void)up;
    if (position) {
        g_audio.listener[0] += 0.01;
        g_audio.listener[1] += 0.01;
        g_audio.listener[2] += 0.01;
    }
}
void native_audio_set_master_volume(double volume) {
    g_audio.master_volume = nyx_clamp(volume, 0.0, 2.0);
}
void native_audio_stop(long long source_id) {
    (void)source_id;
    if (g_audio.active_sources > 0) g_audio.active_sources--;
    g_audio.dsp_ms = nyx_clamp(0.6 + (double)g_audio.active_sources * 0.14, 0.2, 20.0);
}
double native_audio_trace_occlusion(const char * source_id, double lx, double ly, double lz) {
    double dist = lx * lx + ly * ly + lz * lz;
    double hashed = (double)(nyx_hash_cstr(source_id) % 100) / 100.0;
    return nyx_clamp((dist * 0.0002) + hashed * 0.1, 0.0, 1.0);
}
long long native_audio_voice_peers(void) {
    return g_audio.voice_peers;
}
void native_input_capture_mouse(void) {
}
void native_input_release_mouse(void) {
}
NyxBytes native_nyai_build_hybrid_from_intent(const char * intent) {
    g_ai.last_intent_hash = nyx_hash_cstr(intent);
    char tmp[512];
    (void)snprintf(tmp, sizeof(tmp), "hybrid_brain;intent=%s;bt=reactive;goap=enabled;hash=%s", intent ? intent : "", nyx_hex_u64(g_ai.last_intent_hash));
    return nyx_blob_from_text(tmp);
}
NyxBytes native_nyai_run_sandbox(long long step_count) {
    g_ai.last_sandbox_steps = step_count;
    g_ai.frame_ms = nyx_clamp(0.4 + (double)step_count * 0.00003, 0.2, 8.0);
    char tmp[256];
    (void)snprintf(tmp, sizeof(tmp), "sandbox;steps=%lld;frame_ms=%.3f", step_count, g_ai.frame_ms);
    return nyx_blob_from_text(tmp);
}
const char * native_nyanim_adapt_to_physics(const char * clip_id, double slope, double impact, double partial_ragdoll) {
    (void)clip_id;
    (void)slope;
    (void)impact;
    (void)partial_ragdoll;
    return "";
}
NyxBytes native_nyanim_synthesize_intent(const char * intent, double gait, double urgency) {
    (void)intent;
    (void)gait;
    (void)urgency;
    return nyx_empty_bytes();
}
NyxBytes native_nyaudio_compile_zone_graph(long long zone_count, long long edge_count) {
    char tmp[256];
    (void)snprintf(tmp, sizeof(tmp), "audio_zone_graph;zones=%lld;edges=%lld", zone_count, edge_count);
    return nyx_blob_from_text(tmp);
}
NyxStringList native_nyaudio_resolve_music_state(const char * state, double intensity) {
    if (!state) return nyx_empty_string_list();
    if (strcmp(state, "combat") == 0) {
        return nyx_string_list_from4("perc_heavy", "bass_drive", intensity > 0.7 ? "lead_high" : "lead_mid", "drone_tension");
    }
    if (strcmp(state, "chaos") == 0) {
        return nyx_string_list_from4("perc_break", "noise_swells", "sub_pulse", "alarm_layer");
    }
    if (strcmp(state, "tension") == 0) {
        return nyx_string_list_from4("pulse_soft", "strings_tense", intensity > 0.6 ? "high_pad" : "", "");
    }
    return nyx_string_list_from4("pad_calm", "texture_air", "", "");
}
NyxBytes native_nycore_compile_nocode_pipeline(NyxBytes graph_blob, NyxBytes layout_blob, NyxBytes serialization_blob, NyxBytes replication_blob) {
    (void)graph_blob;
    (void)layout_blob;
    (void)serialization_blob;
    (void)replication_blob;
    return nyx_empty_bytes();
}
NyxBytes native_nycore_compile_schema_layout(long long component_count, long long constraint_count) {
    (void)component_count;
    (void)constraint_count;
    return nyx_empty_bytes();
}
NyxBytes native_nycore_compile_schema_replication(long long component_count, long long constraint_count) {
    (void)component_count;
    (void)constraint_count;
    return nyx_empty_bytes();
}
NyxBytes native_nycore_compile_schema_serialization(long long component_count, long long constraint_count) {
    (void)component_count;
    (void)constraint_count;
    return nyx_empty_bytes();
}
NyxBytes native_nycore_compile_visual_graph(long long system_count, long long dependency_count, long long flow_count) {
    (void)system_count;
    (void)dependency_count;
    (void)flow_count;
    return nyx_empty_bytes();
}
long long native_nycore_cpu_count(void) {
    return 0;
}
const char * native_nycore_detect_isa(void) {
    return "";
}
NyxBytes native_nycore_encode(const char * schema_id, long long value_count) {
    (void)schema_id;
    (void)value_count;
    return nyx_empty_bytes();
}
double native_nycore_fragmentation_pct(void) {
    return 0.0;
}
double native_nycore_frame_ms(void) {
    return 0.0;
}
long long native_nycore_memory_mb(void) {
    return 0;
}
void native_nycore_self_optimize(double frame_ms, double cpu_pct, double cache_miss_pct, int auto_parallel, int auto_simd, int dynamic_merge) {
    (void)frame_ms;
    (void)cpu_pct;
    (void)cache_miss_pct;
    (void)auto_parallel;
    (void)auto_simd;
    (void)dynamic_merge;
}
double native_nycore_simd_dot4(const char * isa, double ax, double ay, double az, double aw, double bx, double by, double bz, double bw) {
    (void)isa;
    (void)ax;
    (void)ay;
    (void)az;
    (void)aw;
    (void)bx;
    (void)by;
    (void)bz;
    (void)bw;
    return 0.0;
}
int native_nycore_validate_nocode_pipeline(void) {
    return 0;
}
void native_nygame_bind_engine(const char * name, const char * slot) {
    (void)name;
    (void)slot;
}
void native_nygame_enable_telemetry(const char * name) {
    (void)name;
}
int native_nygame_mount_engine(const char * name, int enabled) {
    (void)name;
    return enabled ? 1 : 0;
}
void native_nygame_report_capability_validation(int ok) {
    (void)ok;
}
void native_nygame_report_production_validation(int ok) {
    (void)ok;
}
void native_nygame_report_sync(int ok) {
    g_nygame_last_sync_ok = ok ? 1 : 0;
}
void native_nygame_set_engine_profile(const char * name, const char * profile) {
    (void)name;
    (void)profile;
}
void native_nygame_shutdown_engine(const char * name) {
    (void)name;
}
void native_nygame_tick_engine(const char * name, double dt) {
    (void)name;
    (void)dt;
}
int native_nygame_verify_engine_capability(const char * name, const char * capability) {
    if (!name || !capability) return 0;
    return nyx_contract_has_capability(name, capability);
}
int native_nygame_verify_engine_profile(const char * name, const char * profile) {
    if (!name || !profile) return 0;
    return nyx_contract_has_profile(name, profile);
}
NyxBytes native_nylogic_compile_graph(long long node_count, long long edge_count) {
    char tmp[256];
    unsigned long long h = (unsigned long long)(node_count * 109 + edge_count * 251 + 29);
    (void)snprintf(tmp, sizeof(tmp), "logic_graph;nodes=%lld;edges=%lld;hash=%s", node_count, edge_count, nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
const char * native_nylogic_decode_rule(NyxBytes rule_blob) {
    static char decoded[1024];
    long long n = rule_blob.len < 1023 ? rule_blob.len : 1023;
    if (!rule_blob.data || n <= 0) {
        decoded[0] = 0;
        return decoded;
    }
    for (long long i = 0; i < n; i++) decoded[i] = (char)rule_blob.data[i];
    decoded[n] = 0;
    return decoded;
}
void native_nylogic_execute(const char * action, NyxBytes payload) {
    g_logic.executed_actions++;
    unsigned long long h = nyx_hash_cstr(action) ^ nyx_fnv1a(payload.data, payload.len);
    g_logic.last_rule_hash = h;
    g_logic.profile_ms = nyx_clamp(g_logic.profile_ms + 0.01, 0.05, 10.0);
}
NyxBytes native_nylogic_generate_rule(const char * prompt) {
    unsigned long long h = nyx_hash_cstr(prompt);
    g_logic.last_rule_hash = h;
    char tmp[768];
    (void)snprintf(tmp, sizeof(tmp), "rule generated_%s when Player enters Bank and Time is Night trigger PoliceResponse(level=3) # prompt=%s", nyx_hex_u64(h), prompt ? prompt : "");
    return nyx_blob_from_text(tmp);
}
int native_nylogic_mutate(const char * rule_id, NyxBytes patch_blob) {
    if (!rule_id || rule_id[0] == 0) return 0;
    if (!patch_blob.data || patch_blob.len <= 0) return 0;
    g_logic.mutation_count++;
    g_logic.last_rule_hash = nyx_hash_cstr(rule_id) ^ nyx_fnv1a(patch_blob.data, patch_blob.len);
    return 1;
}
void native_nylogic_optimize(double frame_ms, double target_ms) {
    if (target_ms <= 0.0) target_ms = 1.0;
    if (frame_ms > target_ms) {
        g_logic.profile_ms = nyx_clamp(target_ms + (frame_ms - target_ms) * 0.25, 0.05, 10.0);
    } else {
        g_logic.profile_ms = nyx_clamp(frame_ms, 0.05, 10.0);
    }
}
double native_nylogic_profile_ms(void) {
    return g_logic.profile_ms;
}
int native_nylogic_validate(const char * rule_id, long long condition_count, long long trigger_count) {
    if (!rule_id || rule_id[0] == 0) return 0;
    if (condition_count <= 0) return 0;
    if (trigger_count <= 0) return 0;
    return 1;
}
NyxBytes native_nynet_autodiscover_replication(long long component_count, long long bandwidth_kbps) {
    char tmp[256];
    (void)snprintf(tmp, sizeof(tmp), "replication_policy;components=%lld;bandwidth_kbps=%lld;mode=auto", component_count, bandwidth_kbps);
    return nyx_blob_from_text(tmp);
}
NyxBytes native_nynet_build_interest_zones(long long entity_count) {
    char tmp[256];
    long long zones = entity_count <= 0 ? 0 : (entity_count / 64) + 1;
    (void)snprintf(tmp, sizeof(tmp), "interest_zones;entities=%lld;zones=%lld", entity_count, zones);
    return nyx_blob_from_text(tmp);
}
const char * native_nynet_checksum(long long frame_id, NyxBytes world_blob) {
    unsigned long long h = ((unsigned long long)frame_id * 11400714819323198485ULL) ^ nyx_fnv1a(world_blob.data, world_blob.len);
    g_net.last_world_hash = h;
    return nyx_hex_u64(h);
}
double native_nynet_packet_loss_pct(void) {
    return g_net.packet_loss_pct;
}
double native_nynet_tick_ms(void) {
    return g_net.tick_ms;
}
int native_nynet_validate_desync(long long frame, const char * local_checksum, const char * remote_checksum) {
    int ok = 0;
    if (local_checksum && remote_checksum && strcmp(local_checksum, remote_checksum) == 0) {
        ok = 1;
        g_net.packet_loss_pct = nyx_clamp(g_net.packet_loss_pct - 0.05, 0.0, 20.0);
        g_net.tick_ms = nyx_clamp(g_net.tick_ms - 0.02, 0.5, 30.0);
    } else {
        g_net.desync_count++;
        g_net.packet_loss_pct = nyx_clamp(g_net.packet_loss_pct + 0.12, 0.0, 20.0);
        g_net.tick_ms = nyx_clamp(g_net.tick_ms + 0.04, 0.5, 30.0);
    }
    (void)frame;
    return ok;
}
void native_nyphysics_apply_template(const char * template_id) {
    nyx_copy_str(g_physics.template_id, sizeof(g_physics.template_id), template_id, "realistic");
    if (strcmp(g_physics.template_id, "arcade") == 0) g_physics.step_ms = 1.7;
    else if (strcmp(g_physics.template_id, "simulation") == 0) g_physics.step_ms = 2.9;
    else if (strcmp(g_physics.template_id, "experimental") == 0) g_physics.step_ms = 3.3;
    else g_physics.step_ms = 2.2;
}
void native_nyphysics_auto_tune(NyxBytes telemetry_blob) {
    double hint = nyx_parse_first_double(telemetry_blob, g_physics.step_ms);
    g_physics.step_ms = nyx_clamp((g_physics.step_ms * 0.7) + (hint * 0.3), 0.5, 8.0);
}
NyxBytes native_nyphysics_compile_constraint_graph(long long node_count, long long edge_count) {
    char tmp[256];
    unsigned long long h = (unsigned long long)(node_count * 41 + edge_count * 73 + 11);
    (void)snprintf(tmp, sizeof(tmp), "constraint_graph;nodes=%lld;edges=%lld;hash=%s", node_count, edge_count, nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
NyxBytes native_nyphysics_compile_nocode_bundle(NyxBytes graph_blob, NyxBytes fracture_blob, const char * template_id) {
    unsigned long long h = nyx_fnv1a(graph_blob.data, graph_blob.len) ^ (nyx_fnv1a(fracture_blob.data, fracture_blob.len) << 1) ^ nyx_hash_cstr(template_id);
    char tmp[256];
    (void)snprintf(tmp, sizeof(tmp), "physics_bundle;template=%s;hash=%s", template_id ? template_id : "", nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
NyxBytes native_nyphysics_generate_fracture_rules(long long material_count) {
    char tmp[256];
    unsigned long long h = (unsigned long long)(material_count * 97 + 7);
    (void)snprintf(tmp, sizeof(tmp), "fracture_rules;materials=%lld;hash=%s", material_count, nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
void native_nyrender_apply_tier(const char * tier) {
    nyx_copy_str(g_render.tier, sizeof(g_render.tier), tier, "high");
}
NyxBytes native_nyrender_compile_material_graph(long long node_count, long long layer_count) {
    char tmp[256];
    unsigned long long h = (unsigned long long)(node_count * 131 + layer_count * 977 + 17);
    (void)snprintf(tmp, sizeof(tmp), "material_graph;nodes=%lld;layers=%lld;hash=%s", node_count, layer_count, nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
NyxBytes native_nyrender_compile_pipeline_graph(long long pass_count, long long edge_count) {
    char tmp[256];
    unsigned long long h = (unsigned long long)(pass_count * 313 + edge_count * 733 + 23);
    (void)snprintf(tmp, sizeof(tmp), "pipeline_graph;passes=%lld;edges=%lld;hash=%s", pass_count, edge_count, nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
NyxBytes native_nyrender_generate_material_from_prompt(const char * prompt) {
    unsigned long long h = nyx_hash_cstr(prompt);
    char tmp[512];
    (void)snprintf(tmp, sizeof(tmp), "prompt_material;prompt=%s;hash=%s;brdf=ggx;layered=1;spectral=1", prompt ? prompt : "", nyx_hex_u64(h));
    return nyx_blob_from_text(tmp);
}
void native_nyrender_register_material_blob(const char * material_id, NyxBytes graph_blob) {
    (unsigned long long)nyx_hash_cstr(material_id);
    (unsigned long long)nyx_fnv1a(graph_blob.data, graph_blob.len);
    g_render.registered_materials++;
}
NyxBytes native_nyworld_compile_world_rules(long long rule_count) {
    (void)rule_count;
    return nyx_empty_bytes();
}
NyxStringList native_nyworld_predict_streaming(NyxBytes profile_blob) {
    (void)profile_blob;
    return nyx_empty_string_list();
}
NyxBytes native_nyworld_simulate_economy(long long tick_index) {
    (void)tick_index;
    return nyx_empty_bytes();
}
void native_physics_boot(void) {
    g_physics.booted = 1;
    g_physics.step_ms = 2.2;
}
const char * native_physics_checksum(long long frame, NyxBytes blob) {
    unsigned long long h = ((unsigned long long)frame * 1315423911ULL) ^ nyx_fnv1a(blob.data, blob.len);
    g_physics.last_checksum = h;
    return nyx_hex_u64(h);
}
double native_physics_query_step_ms(void) {
    return g_physics.booted ? g_physics.step_ms : 0.0;
}
void native_physics_set_float_mode(const char * mode) {
    nyx_copy_str(g_physics.float_mode, sizeof(g_physics.float_mode), mode, "deterministic_fp32");
}
void native_physics_shutdown(void) {
    g_physics.booted = 0;
}
int native_physics_validate_frame(long long frame, NyxBytes state_blob) {
    unsigned long long h = ((unsigned long long)frame * 2654435761ULL) ^ nyx_fnv1a(state_blob.data, state_blob.len);
    if (!g_physics.booted) return 0;
    if (strcmp(g_physics.float_mode, "deterministic_fp32") != 0 && strcmp(g_physics.float_mode, "deterministic_fp64") != 0) return 0;
    return (h != 0ULL) ? 1 : 0;
}
void native_render_boot(const char * backend, long long width, long long height) {
    nyx_copy_str(g_render.backend, sizeof(g_render.backend), backend, "vulkan");
    g_render.width = width > 0 ? width : 1920;
    g_render.height = height > 0 ? height : 1080;
    g_render.booted = 1;
    g_render.registered_materials = 0;
    g_render.gpu_memory_mb = 2048 + (g_render.width * g_render.height) / (1024 * 512);
    g_render.last_gpu_ms = 6.0 + ((double)(g_render.width * g_render.height) / (1920.0 * 1080.0)) * 2.0;
}
long long native_render_query_gpu_memory_mb(void) {
    if (!g_render.booted) return 0;
    long long tier_extra = 0;
    if (strcmp(g_render.tier, "cinematic") == 0) tier_extra = 1024;
    else if (strcmp(g_render.tier, "high") == 0) tier_extra = 512;
    else if (strcmp(g_render.tier, "medium") == 0) tier_extra = 256;
    else tier_extra = 64;
    return g_render.gpu_memory_mb + tier_extra + g_render.registered_materials * 3;
}
double native_render_query_gpu_time_ms(void) {
    if (!g_render.booted) return 0.0;
    double tier_mul = 1.0;
    if (strcmp(g_render.tier, "cinematic") == 0) tier_mul = 1.35;
    else if (strcmp(g_render.tier, "high") == 0) tier_mul = 1.10;
    else if (strcmp(g_render.tier, "medium") == 0) tier_mul = 0.85;
    else tier_mul = 0.65;
    g_render.last_gpu_ms = (5.5 + (double)g_render.registered_materials * 0.03) * tier_mul;
    return g_render.last_gpu_ms;
}
void native_render_shutdown(void) {
    g_render.booted = 0;
    g_render.registered_materials = 0;
    g_render.last_gpu_ms = 0.0;
}
void native_renderer_clear(double r, double g, double b, double a) {
    (void)r;
    (void)g;
    (void)b;
    (void)a;
}
void native_renderer_set_viewport(long long x, long long y, long long width, long long height) {
    (void)x;
    (void)y;
    (void)width;
    (void)height;
}
long long native_time_get_ticks(void) {
    return 0;
}
void native_window_close(void * handle) {
    (void)handle;
}
void * native_window_create(long long width, long long height, const char * title) {
    (void)width;
    (void)height;
    (void)title;
    return NULL;
}
double native_window_get_dpi(void) {
    return 0.0;
}
long long native_window_get_refresh_rate(void) {
    return 0;
}
void native_window_get_size(void * arg0) {
    (void)arg0;
}
int native_window_is_active(void) {
    return 0;
}
void native_window_maximize(void * handle) {
    (void)handle;
}
void native_window_minimize(void * handle) {
    (void)handle;
}
void native_window_restore(void * handle) {
    (void)handle;
}
void native_window_set_fullscreen(void * handle, int enabled) {
    (void)handle;
    (void)enabled;
}
void native_window_set_icon(const char * path) {
    (void)path;
}
void native_window_set_title(void * handle, const char * title) {
    (void)handle;
    (void)title;
}
long long native_world_gpu_memory_used_mb(void) {
    return 0;
}
double native_world_noise(double x, double y, long long octaves) {
    (void)x;
    (void)y;
    (void)octaves;
    return 0.0;
}
NyxBytes native_world_serialize(long long revision, long long records) {
    (void)revision;
    (void)records;
    return nyx_empty_bytes();
}
double native_world_stream_latency_ms(void) {
    return 0.0;
}
